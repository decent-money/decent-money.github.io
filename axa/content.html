
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --ink: #e5e7eb;
      --muted: #9ca3af;
      --accent: #0ea5e9;
      --grid: #1f2937;
      /* Row label colours (by index): 0 = top, 1 = middle, 2 = bottom */
      --good: #3b82f6;
      /* blue for top row */
      --neutral: #9ca3af;
      /* grey for middle row */
      --evil: #dc2626;
      /* red for bottom row */
      --shadow: rgba(0, 0, 0, .35);
      --chip-bg: #0b1220;
      --border: #243045;
      --header-grad-1: rgba(17, 24, 39, .6);
      --header-grad-2: rgba(17, 24, 39, .2);
    }

    .light {
      --bg: #f4f6fb;
      --panel: #ffffff;
      --ink: #0b1220;
      --muted: #6b7280;
      --accent: #0284c7;
      --grid: #e5e7eb;
      --shadow: rgba(0, 0, 0, .15);
      --chip-bg: #f3f4f6;
      --border: #d1d5db;
      --header-grad-1: rgba(255, 255, 255, .8);
      --header-grad-2: rgba(255, 255, 255, .6);
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      margin: 0;
    }

    body {
      background: var(--bg);
      color: var(--ink);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, sans-serif;
      display: flex;
      flex-direction: column;
      overflow-x: hidden;
      /* allow vertical scroll */
      overflow-y: auto;
    }

    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      /* allow content (chart + handles) to extend and be scrollable */
      overflow: visible;
      padding: .5rem;
      gap: .5rem;
    }


    header {
      padding: .5rem .5rem;
      border-bottom: 1px solid var(--grid);
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: .5rem;
      /*background: linear-gradient(180deg, var(--header-grad-1), var(--header-grad-2));*/
    }

    h1 {
      margin: 0;
      font-size: clamp(0.95rem, 2.4vw, 1.25rem);
      font-weight: 650;
    }

    /* Compact, single-line, horizontally scrollable controls for phones */
    .controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
      padding: 0.25rem;
    }

    .controls::-webkit-scrollbar {
      height: 6px;
    }

    .controls::-webkit-scrollbar-thumb {
      background: var(--grid);
      border-radius: 999px;
    }

    .toggle {
      position: relative;
      border: 1px solid var(--border);
      background: linear-gradient(120deg, rgba(255, 94, 220, 0.18), rgba(50, 245, 255, 0.18), rgba(255, 94, 220, 0.18));
      color: var(--ink);
      padding: 0.35rem 0.6rem;
      border-radius: 999px;
      cursor: pointer;
      font-weight: 700;
      font-size: 0.85rem;
      flex: 0 1 auto;
      white-space: nowrap;
      transition: background 0.2s ease;
      font-family: var(--font-sans);
      overflow: hidden;
    }

    .toggle:hover {
      background: color-mix(in oklab, var(--chip-bg) 70%, var(--ink) 10%);
    }

    /* Shimmer border for primary call-to-action */
    .toggle.cta::before {
      content: "";
      position: absolute;
      inset: -1px;
      border-radius: inherit;
      background: linear-gradient(120deg, rgba(255, 94, 220, 0.6), rgba(50, 245, 255, 0.6), rgba(255, 94, 220, 0.6));
      opacity: 0;
      animation: shimmer 5s ease-in-out infinite;
      z-index: 0;
    }

    .toggle.cta {
      z-index: 1;
      font-size: 1.1rem;
      padding: 0.55rem 1.2rem;
    }

    .toggle.cta span {
      position: relative;
      z-index: 1;
      font-size: 1.1em;
      white-space: nowrap;
    }

    @keyframes shimmer {
      0%, 60% {
        opacity: 0;
        transform: translateX(-120%);
      }
      65%, 82% {
        opacity: 0.9;
        transform: translateX(120%);
      }
      100% {
        opacity: 0;
        transform: translateX(120%);
      }
    }

    /* Row that wraps neatly on narrow screens */
    .controls-rowwrap {
      display: flex !important;
      flex-wrap: wrap !important;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      width: 100%;
      margin: 0 0 0.5rem 0;
      padding: 0.25rem;
    }

    /* Keep buttons sized to content, not full width */
    .controls-rowwrap .toggle {
      flex: 0 0 auto;
      white-space: nowrap;
      padding: 0.35rem 0.6rem;
    }

    /* Make sure no earlier mobile rules force a column or 100% width */
    @media (max-width: 600px) {
      .controls-rowwrap {
        flex-direction: row !important;
      }

      .controls-rowwrap .toggle {
        width: auto !important;
      }
    }

    .instruction {
      margin: 0;
      font-size: 0.95rem;
      color: var(--muted);
      width: 100%;
      max-width: 700px;
      text-align: left;
    }

    .instruction ul {
      margin: 0;
      padding-left: 1.2rem;
    }

.board {
  display: grid;
  grid-template-columns: auto repeat(3, 1fr);
  grid-template-rows: auto repeat(3, 1fr);
  gap: var(--board-gap, clamp(0.6rem, 2vw, 1.1rem));
  /* was 0.5rem */
  width: var(--board-size);
  height: var(--board-size);
  position: relative;
}

    .board-wrapper {
      position: relative;
      display: inline-block;
      box-sizing: border-box;
    }

    .resizer-wrap {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 10px;
      margin-top: 16px;
      width: 100%;
      height: 18px;
      position: relative;
    }

    .board-resizer {
      position: relative;
      width: 18px;
      height: 18px;
      border: 1px solid var(--grid);
      border-radius: 4px;
      background: color-mix(in oklab, var(--panel) 75%, transparent);
      cursor: nwse-resize;
      box-shadow: 0 0 8px rgba(0, 0, 0, 0.35);
    }

    .board-resizer::after {
      content: "";
      position: absolute;
      inset: 4px;
      border-right: 1px solid var(--muted);
      border-bottom: 1px solid var(--muted);
      opacity: 0.7;
    }

    .board-resizer:active {
      border-color: var(--accent);
    }

    .resizer-label {
      position: static;
      font-size: 0.8rem;
      color: var(--muted);
      white-space: nowrap;
      user-select: none;
      pointer-events: none;
    }

    .board-watermark {
      position: absolute;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      color: var(--muted);
      opacity: 0.35;
      pointer-events: none;
      /* don‚Äôt block clicks on cells */
      white-space: nowrap;
    }


.hdr {
  display: grid;
  place-items: center;
  font-weight: 800;
  color: var(--muted);
  user-select: none;
  padding: .3rem .55rem;
  border-radius: 8px;
  font-size: 2.1rem;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

    .hdr[role="button"] {
      cursor: text;
      border: 1px dashed transparent;
    }

    .hdr[role="button"]:hover {
      border-color: var(--border);
    }

    .hdr.row {
      writing-mode: vertical-rl;
      text-orientation: mixed;
      transform: rotate(180deg);
    }

    /* 1) Tighter corners on cells */
    .cell {
      border-radius: 8px;
      /* was 14px */
      position: relative;
      border: 1px solid var(--grid);
      background: var(--panel);
      display: grid;
      place-items: center;
      overflow: hidden;
    }

    .alignment {
      position: absolute;
      top: 6px;
      left: 50%;
      transform: translateX(-50%);
      text-transform: uppercase;
      font-weight: 800;
      line-height: 1.15;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 92%;
      text-align: center;
      display: block;
      pointer-events: none;
      font-size: var(--alignment-font-size, 12px);
      /* NEW: shared size */
    }

    .cell[data-row-index="0"] .alignment {
      color: var(--good);
    }

    .cell[data-row-index="1"] .alignment {
      color: var(--neutral);
    }

    .cell[data-row-index="2"] .alignment {
      color: var(--evil);
    }

    /* 4) Avatar stays centered; size set by JS */
.content {
  width: 100%;
  height: 100%;
  display: grid;
  place-items: center;
}

.avatar {
  border-radius: 50%;
  border: 2px solid var(--grid);
  object-fit: cover;
  transition: transform 0.2s ease, width 0.2s ease, height 0.2s ease;
}

.custom-image {
  border-radius: 10px;
  border: none;
  object-fit: contain;
  background: var(--panel);
  transition: transform 0.2s ease, width 0.2s ease, height 0.2s ease;
}

.image-unavailable {
  display: none;
  position: absolute;
  inset: 0;
  place-items: center;
  color: var(--muted);
  font-size: 0.9rem;
  text-align: center;
  pointer-events: none;
}


    .handle {
      position: absolute;
      bottom: 6px;
      left: 50%;
      transform: translateX(-50%);
      font-weight: 700;
      white-space: nowrap;
      /* single line */
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 92%;
      transition: none;
      color: var(--ink);
      text-align: center;
    }

    .handle a {
      color: inherit;
      text-decoration: underline;
      text-underline-offset: 3px;
    }

    .handle a:link,
    .handle a:visited,
    .handle a:hover,
    .handle a:active {
      color: inherit;
      text-decoration: underline;
    }

    .placeholder {
      color: var(--muted);
      font-size: .9rem;
    }

    .plain-text {
      color: var(--ink);
      font-weight: 700;
      text-align: center;
      max-width: 90%;
      word-break: break-word;
    }

    .inline-edit {
      display: flex;
      align-items: center;
      gap: .4rem;
    }

    .inline-edit.image-edit {
      flex-direction: column;
      align-items: center;
    }

    .inline-edit.image-edit input {
      width: 100%;
    }

    .inline-edit input {
      padding: .4rem .5rem;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--chip-bg);
      color: var(--ink);
      outline: none;
      width: 8rem;
    }

    .inline-edit input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px color-mix(in oklab, var(--accent) 35%, transparent);
    }

    .handles-row {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.4rem;
      margin-top: 0.25rem;
      padding-bottom: 0.5rem;
      /* a little breathing room above bottom edge */
    }

    .handles-actions {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .copy-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.15rem;
    }

    .copy-note {
      font-family: var(--font-sans);
      font-size: 0.9rem;
      letter-spacing: 0.12em;
      color: var(--muted);
      margin-top: 0.1rem;
    }

    .copy-group .icon-button {
      min-width: 81.2667px;
    }

    .share-button {
      border: 1px solid var(--border);
      background: var(--chip-bg);
      color: var(--accent-cyan);
      border-radius: 999px;
      padding: 0.35rem 0.8rem;
      cursor: pointer;
      font-size: 0.95rem;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      text-decoration: none;
      font-family: var(--font-sans);
    }

    .share-button:hover {
      background: color-mix(in oklab, var(--chip-bg) 70%, var(--ink) 10%);
    }

    .download-button {
      border: 1px solid var(--border);
      background: var(--chip-bg);
      color: var(--accent);
      border-radius: 999px;
      padding: 0.35rem 0.8rem;
      cursor: pointer;
      font-size: 0.95rem;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      text-decoration: none;
      font-family: var(--font-sans);
    }

    .download-button:hover {
      background: color-mix(in oklab, var(--chip-bg) 70%, var(--ink) 10%);
    }

.char-counter {
  font-size: 0.75rem;
  color: var(--muted);
  line-height: 1;
  align-self: flex-end;
  margin-top: 0.35rem;
}

.char-counter.over-limit {
  color: #dc2626;
  /* red when over 240 */
    }

    .handles-wrapper {
      width: var(--board-size);
      max-width: 100%;
      box-sizing: border-box;
      border: 1px dashed rgba(255, 255, 255, 0.15);
      border-radius: 14px;
      padding: 0.9rem 1rem 0.6rem;
      background: color-mix(in oklab, var(--panel) 92%, transparent);
    }

    .frame-wrap {
      border: 1px dashed rgba(255, 255, 255, 0.15);
      border-radius: 16px;
      padding: 16px;
      box-sizing: border-box;
      display: inline-block;
      position: relative;
    }

    #handlesText {
      margin: 0;
      text-align: center;
      font-size: 1rem;
      color: var(--ink);
      word-wrap: break-word;
      white-space: pre-wrap;
      max-width: 80vw;
      line-height: 1.6;
    }

    .icon-button {
      border: 1px solid var(--border);
      background: var(--chip-bg);
      color: var(--ink);
      border-radius: 999px;
      padding: 0.25rem 0.5rem;
      cursor: pointer;
      font-size: 1rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .icon-button:hover {
      background: color-mix(in oklab, var(--chip-bg) 70%, var(--ink) 10%);
    }

    .icon-button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }


    /* Make toggle buttons able to host an inner bar */
    .toggle {
      position: relative;
      overflow: hidden;
    }

    /* Optional: visual disabled state */
    .toggle[disabled] {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* The cooldown bar inside the refresh button */
    .cooldown-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 3px;
      width: 0;
      background: var(--accent);
      pointer-events: none;
      opacity: 0;
      /* NEW: invisible until cooldown starts */
    }


    /* When cooling: animate the bar from 0% to 100% over the cooldown */
    .refresh-cooling .cooldown-bar {
      opacity: 1;
      animation: cooldownFill 60000ms linear forwards;
    }


    @keyframes cooldownFill {
      from {
        width: 0%;
      }

      to {
        width: 100%;
      }
    }
  </style>

<body>
  <header>
    <h1>Allies <span class="x-symbol">X</span> Axis (A<span class="x-symbol">X</span>A) Alignment Chart</h1>
  </header>

  <main>

    <div class="instruction" style="margin-left: 0; text-align: left; max-width: none;">
      <ul>
        <li>You can add 3 main types of content to each cell:</li>
        <ul>
          <li><strong><span class="x-symbol">X</span> accounts:</strong> Type an <span class="x-symbol">X</span> handle including the @. Displays the avatar (if possible, or a placeholder).</li>
          <li><strong>Plain text:</strong> Type any text you want to display. Keep it short.</li>
          <li><strong>Images (+label):</strong> Paste an image from your clipboard (NOT image URL addresses, actual image data). After pasting image, add an optional custom label.</li>
        </ul>
        <li>Labels for columns and rows also editable if you want to make a custom alignment chart (or click
          the <strong>FMK Labels</strong> button for a quick format change).</li>
      </ul>
      <p><strong>Note:</strong> Sometimes <span class="x-symbol">X</span> avatars won't load from <a href="https://unavatar.io/">unavatar.io</a> so a placeholder from <a
          href="https://www.dicebear.com/">dicebear.com</a> will be displayed instead.</p>
    </div>
      
    <div class="controls controls-rowwrap" role="toolbar" aria-label="Chart controls">
      <button id="labelsBtn" class="toggle" aria-pressed="true">Labels: On</button>
      <button id="refreshBtn" class="toggle">
        <span class="btn-label">Refresh Avatars</span>
        <span class="cooldown-bar"></span>
      </button>
      <button id="clearBtn" class="toggle">Clear Entries</button>
      <button id="resetLabelsBtn" class="toggle">Default Labels</button>
      <button id="fmkLabelsBtn" class="toggle">FMK Labels</button>
    </div>

    <div class="frame-wrap">
    <div class="board-wrapper">
    <div class="board" id="board" aria-label="Alignment grid">
      <!-- Corner -->
      <div class="hdr" aria-hidden="true"></div>
      <!-- Column headers (editable) -->
      <div id="col-0" class="hdr col" role="button" style="grid-column: 2; grid-row: 1; margin-bottom: -10px;">Lawful</div>
      <div id="col-1" class="hdr col" role="button" style="grid-column: 3; grid-row: 1; margin-bottom: -10px;">Neutral</div>
      <div id="col-2" class="hdr col" role="button" style="grid-column: 4; grid-row: 1; margin-bottom: -10px;">Chaotic</div>

      <!-- Row headers (editable) -->
      <div id="row-0" class="hdr row" role="button" style="grid-column: 1; grid-row: 2; margin-right: -10px;">Good</div>
      <div id="row-1" class="hdr row" role="button" style="grid-column: 1; grid-row: 3; margin-right: -10px;">Neutral</div>
      <div id="row-2" class="hdr row" role="button" style="grid-column: 1; grid-row: 4; margin-right: -10px;">Evil</div>

      <!-- Cells -->
      <div class="cell" id="cell-lg" data-row-index="0" data-col-index="0" role="gridcell"
        style="grid-column: 2; grid-row: 2;">
        <span class="alignment"></span>
        <div class="content">
          <div class="placeholder">Click to add</div>
        </div>
      </div>
      <div class="cell" id="cell-ng" data-row-index="0" data-col-index="1" role="gridcell"
        style="grid-column: 3; grid-row: 2;">
        <span class="alignment"></span>
        <div class="content">
          <div class="placeholder">Click to add</div>
        </div>
      </div>
      <div class="cell" id="cell-cg" data-row-index="0" data-col-index="2" role="gridcell"
        style="grid-column: 4; grid-row: 2;">
        <span class="alignment"></span>
        <div class="content">
          <div class="placeholder">Click to add</div>
        </div>
      </div>

      <div class="cell" id="cell-ln" data-row-index="1" data-col-index="0" role="gridcell"
        style="grid-column: 2; grid-row: 3;">
        <span class="alignment"></span>
        <div class="content">
          <div class="placeholder">Click to add</div>
        </div>
      </div>
      <div class="cell" id="cell-nn" data-row-index="1" data-col-index="1" role="gridcell"
        style="grid-column: 3; grid-row: 3;">
        <span class="alignment"></span>
        <div class="content">
          <div class="placeholder">Click to add</div>
        </div>
      </div>
      <div class="cell" id="cell-cn" data-row-index="1" data-col-index="2" role="gridcell"
        style="grid-column: 4; grid-row: 3;">
        <span class="alignment"></span>
        <div class="content">
          <div class="placeholder">Click to add</div>
        </div>
      </div>

      <div class="cell" id="cell-le" data-row-index="2" data-col-index="0" role="gridcell"
        style="grid-column: 2; grid-row: 4;">
        <span class="alignment"></span>
        <div class="content">
          <div class="placeholder">Click to add</div>
        </div>
      </div>
      <div class="cell" id="cell-ne" data-row-index="2" data-col-index="1" role="gridcell"
        style="grid-column: 3; grid-row: 4;">
        <span class="alignment"></span>
        <div class="content">
          <div class="placeholder">Click to add</div>
        </div>
      </div>
      <div class="cell" id="cell-ce" data-row-index="2" data-col-index="2" role="gridcell"
        style="grid-column: 4; grid-row: 4;">
        <span class="alignment"></span>
        <div class="content">
          <div class="placeholder">Click to add</div>
        </div>
      </div>
      <div id="boardWatermark" class="board-watermark">dm2k9.net/axa</div>
    </div>
    </div> <!-- end board-wrapper -->
    <div class="resizer-wrap">
      <div class="resizer-label">Drag to resize</div>
      <div class="board-resizer" id="boardResizer" aria-label="Resize board" title="Drag to resize"></div>
    </div>
    <div class="handles-row" style="margin-top: 1.75rem;">
      <div class="handles-wrapper">
        <p id="handlesText"></p>
      </div>
      <div id="charCounter" class="char-counter">0 / 280</div>
    </div>
    </div> <!-- end frame-wrap -->

    <div class="handles-actions" style="margin-top: 0.75rem;">
      <div class="copy-group">
        <button id="copyHandlesBtn" class="toggle cta" type="button" aria-label="Copy grid, start X post"
          title="Copy grid, start X post">
          <span>Copy grid, start ùïè post...</span>
        </button>
        <span class="copy-note">and paste clipboard contents into ùïè post.</span>
      </div>
    </div>

  </main>

  <script>
    // ==== Defaults & persisted titles ====
    const DEFAULT_MID_HANDLE = 'decentmoney2009'; // without @
    const DEFAULT_COLS = ['Lawful', 'Neutral', 'Chaotic'];
    const DEFAULT_ROWS = ['Good', 'Neutral', 'Evil'];
    const charCounter = document.getElementById('charCounter');
    const CHAR_LIMIT = 280;
    const ALIGN_FONT_MIN = 11;
    const ALIGN_FONT_MAX = 18;

    const FONT_MAP = {
      'helvetica': '"Helvetica", "Arial", sans-serif',
      'arial': '"Arial", "Helvetica", sans-serif',
      'arial black': '"Arial Black", "Arial Black", "Arial", sans-serif',
      'tahoma': '"Tahoma", "Geneva", sans-serif',
      'trebuchet ms': '"Trebuchet MS", "Tahoma", "Geneva", sans-serif',
      'lucida sans': '"Lucida Sans", "Lucida Sans Unicode", "Lucida Grande", sans-serif',
      'lucida grande': '"Lucida Grande", "Lucida Sans Unicode", sans-serif',
      'gill sans': '"Gill Sans", "Gill Sans MT", "Calibri", sans-serif',
      'optima': '"Optima", "Segoe UI", sans-serif',
      'didot': '"Didot", "Georgia", serif',
      'palatino': '"Palatino", "Palatino Linotype", "Book Antiqua", serif',
      'palatino linotype': '"Palatino Linotype", "Palatino", "Book Antiqua", serif',
      'book antiqua': '"Book Antiqua", "Palatino", serif',
      'candara': '"Candara", "Segoe UI", sans-serif',
      'century gothic': '"Century Gothic", "Apple Gothic", sans-serif',
      'franklin gothic': '"Franklin Gothic Medium", "Arial Narrow", Arial, sans-serif',
      'rockwell': '"Rockwell", "Georgia", serif',
      'bahnschrift': '"Bahnschrift", "Segoe UI", sans-serif',
      'segoe ui': '"Segoe UI", "Tahoma", sans-serif',
      'segoe print': '"Segoe Print", "Comic Sans MS", cursive',
      'segoe script': '"Segoe Script", "Comic Sans MS", cursive',
      'segoe ui emoji': '"Segoe UI Emoji", "Segoe UI Symbol", "Segoe UI", sans-serif',
      'segoe ui symbol': '"Segoe UI Symbol", "Segoe UI", sans-serif',
      'cambria': '"Cambria", "Georgia", serif',
      'constantia': '"Constantia", "Georgia", serif',
      'corbel': '"Corbel", "Segoe UI", sans-serif',
      'menlo': '"Menlo", "Monaco", "Consolas", "Liberation Mono", monospace',
      'monaco': '"Monaco", "Consolas", "Menlo", monospace',
      'lucida console': '"Lucida Console", "Lucida Sans Typewriter", monospace',
      'andale mono': '"Andale Mono", "Monaco", monospace',
      'calibri': '"Calibri", "Segoe UI", sans-serif',
      'comic sans': '"Comic Sans MS", "Comic Sans", cursive',
      'comic sans ms': '"Comic Sans MS", "Comic Sans", cursive',
      'comicsans': '"Comic Sans MS", "Comic Sans", cursive',
      'courier': '"Courier New", Courier, monospace',
      'courier new': '"Courier New", Courier, monospace',
      'times new roman': '"Times New Roman", Times, serif',
      'impact': '"Impact", "Haettenschweiler", "Arial Narrow Bold", sans-serif',
      'wingdings': '"Wingdings", "Zapf Dingbats", fantasy',
      'windings': '"Wingdings", "Zapf Dingbats", fantasy',
      'papyrus': '"Papyrus", fantasy',
      'chiller': '"Chiller", fantasy',
      'verdana': '"Verdana", "Geneva", sans-serif',
      'georgia': '"Georgia", serif',
      'garamond': '"Garamond", serif',
      'consolas': '"Consolas", "Monaco", monospace'
    };

    function fontFamilyFor(text) {
      if (!text) return '';
      const key = text.toLowerCase().replace(/[^a-z0-9 ]+/g, ' ').replace(/\s+/g, ' ').trim();
      return FONT_MAP[key] || '';
    }

    // Track a stable viewport height to avoid iOS/Android browser chrome causing jumps
    let stableViewportHeight = window.innerHeight;
    let userBoardSize = null; // manual override set by drag-resize
    const PLACEHOLDER_IMG = `data:image/svg+xml;charset=UTF-8,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="400" height="400"><rect width="100%" height="100%" fill="%232a1042"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="%23a88dc9" font-size="20">image</text></svg>')}`;

    let colTitles = JSON.parse(localStorage.getItem('alignment_col_titles') || 'null') || [...DEFAULT_COLS];
    let rowTitles = JSON.parse(localStorage.getItem('alignment_row_titles') || 'null') || [...DEFAULT_ROWS];
    function saveTitles() { localStorage.setItem('alignment_col_titles', JSON.stringify(colTitles)); localStorage.setItem('alignment_row_titles', JSON.stringify(rowTitles)); }

    function supportsChar(char) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.font = '16px sans-serif';
      const baseline = ctx.measureText('m').width;
      return ctx.measureText(char).width !== baseline;
    }

    // Use blackletter ùïè if supported, fall back to normal X otherwise
    const X_SYMBOL = supportsChar('ùïè') ? 'ùïè' : 'X';
    // TEST MODE: pretend ùïè is unsupported
    //const X_SYMBOL = 'X';


    function applyXSymbolFallback() {
      document.querySelectorAll('.x-symbol').forEach(el => {
        el.textContent = X_SYMBOL;
      });
    }


    // ==== Utilities ====
    function parseHandle(value) {
      if (!value) return '';
      const raw = value.trim();
      if (!raw.startsWith('@')) return '';

      let v = raw.replace(/^@+/, '');

      // Allow a URL after the @, but still require the explicit @ prefix
      try {
        if (/^https?:\/\//i.test(v)) {
          const u = new URL(v);
          const h = u.hostname.replace(/^www\./, '').toLowerCase();
          if (h.endsWith('x.com') || h.endsWith('twitter.com')) {
            v = u.pathname.split('/').filter(Boolean)[0] || '';
          }
        }
      } catch { /* ignore URL parse errors */ }

      v = v.split(/[/?#]/)[0].replace(/[^a-zA-Z0-9_]/g, '');
      return v;
    }

    const IMAGE_EXT_RE = /\.(png|jpe?g|gif|webp|svg)(\?.*)?$/i;

    function parseImageEntry(value) {
      if (!value) return null;
      const parts = value.split('|');
      const url = (parts.shift() || '').trim();
      // Only allow pasted data URLs (no external links)
      if (!/^data:image\//i.test(url)) return null;
      const urlNoQuery = url.split('?')[0];
      const hasExt = IMAGE_EXT_RE.test(urlNoQuery);
      const hasHint = /width=|height=|image|img|format=|jpeg|jpg|png|gif|webp/i.test(url);
      const label = parts.join('|').trim();
      if (!hasExt && !hasHint && !label && !/^data:image\//i.test(url)) return null; // avoid treating arbitrary links as images
      return { url, label };
    }

    function showImageUnavailable(el) {
      if (!el) return;
      const msg = el.querySelector('.image-unavailable');
      if (msg) msg.style.display = 'grid';
    }


    function avatarURL(handle) {
      const encodedHandle = encodeURIComponent(handle);

      // Fallback avatar provider (avatar.vercel.sh in your example)
      //const fallbackBase = `https://avatar.vercel.sh/${encodedHandle}?size=400`;
      const fallbackBase = `https://api.dicebear.com/7.x/thumbs/svg?seed=${encodedHandle}`;

      const fallbackParam = encodeURIComponent(fallbackBase);

      // unavatar with X provider + fallback
      return `https://unavatar.io/x/${encodedHandle}?fallback=${fallbackParam}`;
    }


    const profileURL = h => `https://x.com/${encodeURIComponent(h)}`;

    // ==== Handles line ====
    const handlesText = document.getElementById('handlesText');
    const handlesWrapper = document.querySelector('.handles-wrapper');

    function syncHandlesWidth() {
      const board = document.getElementById('board');
      if (!board || !handlesWrapper) return;
      const w = board.getBoundingClientRect().width;
      handlesWrapper.style.width = `${w}px`;
      handlesWrapper.style.maxWidth = '100%';
      handlesWrapper.style.boxSizing = 'border-box';
    }

    function fitHeadersResponsive() {
      const colHeaders = Array.from(document.querySelectorAll('.hdr.col'));
      const rowHeaders = Array.from(document.querySelectorAll('.hdr.row'));
      const all = [...colHeaders, ...rowHeaders];
      if (!all.length) return;
      const base = 2.1; // rem
      const min = 0.7;
      const step = 0.05;

      const measureFit = el => {
        let size = base;
        el.style.fontSize = `${size}rem`;
        while (size > min && (el.scrollWidth > el.clientWidth || el.scrollHeight > el.clientHeight)) {
          size -= step;
          el.style.fontSize = `${size}rem`;
        }
        return size;
      };

      const sizes = all.map(measureFit);
      const finalSize = Math.max(min, Math.min(...sizes));
      all.forEach(h => (h.style.fontSize = `${finalSize}rem`));
    }

    function countForX(text) {
      if (!text) return 0;
      const weight = str => Array.from(str).reduce((sum, ch) => {
        const cp = ch.codePointAt(0);
        return sum + (cp > 0xffff ? 2 : 1); // emoji/astral count as 2
      }, 0);

      let total = weight(text);

      // Rough URL detection; X counts any URL as 23 characters
      const urlRe = /(?:https?:\/\/|www\.)\S+|(?:\S+\.\S+\/\S*)/gi;
      const seen = text.match(urlRe) || [];
      seen.forEach(url => {
        total -= weight(url);
        total += 23; // X t.co length
      });
      return total;
    }

    function updateHandlesText() {
      // Read existing column/row titles
      const colLine = `${colTitles[0]} | ${colTitles[1]} | ${colTitles[2]}`;
      const rowLine = `${rowTitles[0]} | ${rowTitles[1]} | ${rowTitles[2]}`;

      // Two-line header: Columns ùïè Rows (using X_SYMBOL)
      const alignmentHeader = `${colLine} ${X_SYMBOL} ${rowLine}`;

      // Build handle/text list; placeholder ? for empty slots
      const entries = [...document.querySelectorAll('.cell')].map(c => {
        const raw = (c.dataset.raw || '').trim();
        if (!raw) return '?,';
        if (raw.startsWith('@')) {
          const h = parseHandle(raw);
          return h ? `@${h},` : '?';
        }
        const img = parseImageEntry(raw);
        if (img) {
          const cellIndex = () => {
            const r = Number(c.dataset.rowIndex);
            const cIdx = Number(c.dataset.colIndex);
            return r * 3 + cIdx + 1;
          };
          const lbl = img.label || `Img${cellIndex()}`;
          return `${lbl},`;
        }
        // Plain text entries get a trailing comma for separation
        return `${raw},`;
      });

      // Remove trailing comma on the last cell entry
      if (entries.length) {
        entries[entries.length - 1] = entries[entries.length - 1].replace(/,+$/, '');
      }

      const handles = entries.join(' ').replace(/\s+,/g, ','); // clean any stray space before commas


      // Always include suffix URL
      const suffix = 'dm2k9.net/axa';
      const handleLine = handles ? `${handles}\n\n${suffix}` : suffix;

      // Final text block shown under the chart
      const fullText = `${alignmentHeader}\n\n${handleLine}`;
      handlesText.textContent = fullText;

      // Character counter logic
      if (charCounter) {
        const textForCount = handlesText.textContent || '';
        const len = countForX(textForCount);
        charCounter.textContent = `${len} / ${CHAR_LIMIT}`;
        charCounter.classList.toggle('over-limit', len > CHAR_LIMIT);
      }

      // Resizing flow remains intact
      requestAnimationFrame(sizeBoard);
    }


    const copyHandlesBtn = document.getElementById('copyHandlesBtn');

    async function copyHandlesToClipboard() {
      const text = handlesText.textContent || '';
      copyHandlesBtn.disabled = true;

      try {
        let imageBlob = null;
        try {
          imageBlob = await downloadScreenshot(true);
        } catch (e) {
          console.warn('Image capture failed; copying text only', e);
        }

        let copied = false;

        // Preferred: single item with both image and text (if supported)
        if (navigator.clipboard && navigator.clipboard.write && window.ClipboardItem && (imageBlob || text)) {
          const payload = {};
          if (imageBlob) payload[imageBlob.type] = imageBlob;
          if (text) payload['text/plain'] = new Blob([text], { type: 'text/plain' });
          try {
            await navigator.clipboard.write([new ClipboardItem(payload)]);
            copied = true;
          } catch (err) {
            console.warn('Combined clipboard write failed, trying fallbacks', err);
          }
        }

        // Fallback: image-only if available and supported
        if (!copied && imageBlob && navigator.clipboard && navigator.clipboard.write && window.ClipboardItem) {
          try {
            await navigator.clipboard.write([new ClipboardItem({ [imageBlob.type]: imageBlob })]);
            copied = true;
          } catch (err) {
            console.warn('Image-only clipboard write failed', err);
          }
        }

        // Fallback: text-only
        if (!copied && text) {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(text);
            copied = true;
          } else {
            const temp = document.createElement('textarea');
            temp.value = text;
            temp.style.position = 'fixed';
            temp.style.opacity = '0';
            document.body.appendChild(temp);
            temp.select();
            document.execCommand('copy');
            document.body.removeChild(temp);
            copied = true;
          }
        }

        const original = copyHandlesBtn.dataset.label || copyHandlesBtn.textContent;
        copyHandlesBtn.dataset.label = original;
        copyHandlesBtn.textContent = copied ? '‚úì' : 'Copy failed';
        if (copied) copyHandlesBtn.style.color = '#5CFF5C';

        const startXRedirect = () => {
          const intent = `https://x.com/intent/tweet`;
          window.open(intent, '_blank', 'noopener');
        };

        const showRedirecting = () => {
          const dots = ['.', '..', '...'];
          let i = 0;
          const tick = setInterval(() => {
            copyHandlesBtn.textContent = `Redirecting${dots[i]}`;
            copyHandlesBtn.style.color = ''; // reset to normal color
            i++;
            if (i >= dots.length) {
              clearInterval(tick);
              startXRedirect();
              copyHandlesBtn.textContent = original;
              copyHandlesBtn.style.color = '';
              copyHandlesBtn.disabled = false;
            }
          }, 333);
        };

        setTimeout(() => {
          if (copied) {
            showRedirecting();
          } else {
            copyHandlesBtn.textContent = original;
            copyHandlesBtn.style.color = '';
            copyHandlesBtn.disabled = false;
          }
        }, 800);
      } catch {
        copyHandlesBtn.disabled = false;
        alert('Could not copy. Try a modern browser with clipboard access or copy manually.');
      }
    }

    copyHandlesBtn.addEventListener('click', copyHandlesToClipboard);
    syncHandlesWidth();
    fitHeadersResponsive();

    async function loadDomToImage() {
      if (window.domtoimage) return window.domtoimage;
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = 'https://cdn.jsdelivr.net/npm/dom-to-image-more@3.3.0/dist/dom-to-image-more.min.js';
        s.async = true;
        s.onload = () => resolve(window.domtoimage);
        s.onerror = () => reject(new Error('Failed to load dom-to-image-more'));
        document.head.appendChild(s);
      });
    }

    async function downloadScreenshot(returnBlobOnly = false) {
      const target = document.querySelector('.board');
      if (!target) return;
      const rect = target.getBoundingClientRect();
      const w = Math.round(rect.width);
      const h = Math.round(rect.height);
      const pad = 16;

      // Clone target to avoid flashing live DOM and wrap with padding
      const clone = target.cloneNode(true);
      clone.style.position = 'relative';
      clone.style.width = `${w}px`;
      clone.style.height = `${h}px`;
      clone.style.transform = 'none';

      const shot = document.createElement('div');
      shot.style.position = 'absolute';
      shot.style.left = '-99999px';
      shot.style.top = '0';
      shot.style.width = `${w + pad * 2}px`;
      shot.style.height = `${h + pad * 2}px`;
      shot.style.padding = `${pad}px`;
      shot.style.backgroundColor = '#0a0414';
      shot.appendChild(clone);
      document.body.appendChild(shot);

      // Inline all images on the clone to avoid CORS/taint issues
      const inlineImages = async root => {
        const imgs = Array.from(root.querySelectorAll('img'));
        const originals = [];

        const toDataUrl = blob =>
          new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.readAsDataURL(blob);
          });

        const waitForLoad = img =>
          new Promise(resolve => {
            if (img.complete && img.naturalWidth) return resolve();
            img.onload = () => resolve();
            img.onerror = () => resolve();
          });

        for (const img of imgs) {
          const src = img.getAttribute('src') || img.currentSrc;
          if (!src || src.startsWith('data:')) continue;
          originals.push({ img, src });
          try {
            const resp = await fetch(src, { mode: 'cors', credentials: 'omit', referrerPolicy: 'no-referrer' });
            if (!resp.ok) throw new Error('fetch failed');
            const blob = await resp.blob();
            const dataUrl = await toDataUrl(blob);
            img.src = dataUrl;
            await waitForLoad(img);
          } catch (e) {
            // Fallback: simple placeholder SVG
            img.src = PLACEHOLDER_IMG;
            await waitForLoad(img);
            const cell = img.closest('.cell');
            if (cell) {
              showImageUnavailable(cell);
            }
          }
        }

        return () => {
          originals.forEach(({ img, src }) => {
            img.src = src;
          });
        };
      };

      try {
        const domtoimage = await loadDomToImage();
        const restoreImages = await inlineImages(shot);
        const dataUrl = await domtoimage.toPng(shot, {
          bgcolor: '#0a0414',
          width: w + pad * 2,
          height: h + pad * 2,
          cacheBust: true,
          style: {
            width: `${w + pad * 2}px`,
            height: `${h + pad * 2}px`,
            transform: 'none'
          },
          quality: 1,
          imagePlaceholder: PLACEHOLDER_IMG
        });
        restoreImages && restoreImages();
        const res = await fetch(dataUrl);
        const blob = await res.blob();
        shot.remove();
        if (returnBlobOnly) return blob;
        // Default: download if invoked directly without blob request
        const a = document.createElement('a');
        a.href = dataUrl;
        a.download = 'axa-grid.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      } catch (err) {
        console.error('Screenshot capture failed', err);
        alert('Could not capture screenshot. Please try again. If this persists, try refreshing or replacing external images.');
        shot.remove();
        if (returnBlobOnly) throw err;
      }
    }


    const isMobileViewport = () => window.matchMedia('(max-width: 900px)').matches;

    function fitAllAlignmentLabels() {
      const labels = Array.from(document.querySelectorAll('.alignment'));
      if (!labels.length) return;

      // Hide all labels if toggled off
      if (!labelsVisible) {
        labels.forEach(l => { l.style.display = 'none'; });
        return;
      }

      labels.forEach(l => {
        l.style.display = 'block';
        l.style.whiteSpace = 'nowrap';
        l.style.webkitLineClamp = '';
        l.style.webkitBoxOrient = '';
      });

      const cells = labels.map(l => l.closest('.cell')).filter(Boolean);
      if (!cells.length) return;

      // Use the smallest cell size to determine a uniform font size
      const minBase = Math.min(...cells.map(c => {
        const r = c.getBoundingClientRect();
        return Math.min(r.width, r.height);
      }));

      let size = Math.min(ALIGN_FONT_MAX, Math.max(ALIGN_FONT_MIN, minBase * 0.11));
      const avail = c => c.getBoundingClientRect().width * 0.9;

      const applySize = () => {
        labels.forEach(l => {
          l.style.fontSize = `${size}px`;
          l.style.setProperty('--alignment-font-size', `${size}px`);
        });
      };

      const fitsAllSingleLine = () => labels.every((l, i) => l.scrollWidth <= avail(cells[i]));

      applySize();
      let guard = 40;
      while (!fitsAllSingleLine() && size > ALIGN_FONT_MIN && guard--) {
        size -= 0.5;
        applySize();
      }

      // Allow wrapping only when needed after hitting minimum size
      labels.forEach((l, i) => {
        if (l.scrollWidth > avail(cells[i])) {
          l.style.whiteSpace = 'normal';
          l.style.display = '-webkit-box';
          l.style.webkitBoxOrient = 'vertical';
          l.style.webkitLineClamp = '2';
        }
      });
    }

    function applyBoardSize(size) {
      const board = document.getElementById('board');
      board.style.setProperty('--board-size', size + 'px');
      board.style.width = size + 'px';
      board.style.height = size + 'px';
      // Scale gaps a bit tighter on smaller boards
      const gap = (() => {
        const minSize = 260;
        const maxSize = 900;
        const t = Math.max(0, Math.min(1, (size - minSize) / (maxSize - minSize)));
        const minGap = 0.6;
        const maxGap = 1.1;
        return (minGap + (maxGap - minGap) * t).toFixed(3) + 'rem';
      })();
      board.style.setProperty('--board-gap', gap);
      fitAllAlignmentLabels();
      updateAvatarSizes();
      positionWatermark();
      syncHandlesWidth();
    }

    function sizeBoard() {
      const headerH = document.querySelector('header').offsetHeight;
      const instructionH = document.querySelector('.instruction').offsetHeight + 6;
      const padding = 16; // main padding + breathing room

      if (userBoardSize) {
        applyBoardSize(userBoardSize);
        return;
      }

      // Use a stable viewport height on mobile to avoid address bar resize jumps
      const viewportH = isMobileViewport()
        ? Math.max(stableViewportHeight, window.innerHeight)
        : window.innerHeight;

      // Only reserve space for header + instruction; handles can scroll below.
      const availH = viewportH - headerH - instructionH - padding;
      const availW = window.innerWidth - padding;

      const size = Math.max(260, Math.min(availW, availH)); // 260px minimum for small phones

      applyBoardSize(size);
      fitHeadersResponsive();
    }


    window.addEventListener('resize', () => {
      // Update stable height when the viewport grows (e.g., chrome hidden)
      if (window.innerHeight > stableViewportHeight) {
        stableViewportHeight = window.innerHeight;
      }
      sizeBoard();
      fitHeadersResponsive();
    }, { passive: true });

    window.addEventListener('orientationchange', () => {
      stableViewportHeight = window.innerHeight;
      sizeBoard();
      fitHeadersResponsive();
    });

    // ==== Alignment labels (include True X when row == col) ====
    function setAlignmentLabel(cell) {
      const r = Number(cell.dataset.rowIndex);
      const c = Number(cell.dataset.colIndex);
      const span = cell.querySelector('.alignment');
      const col = (colTitles[c] || '').trim();
      const row = (rowTitles[r] || '').trim();
      if (col.toLowerCase() === row.toLowerCase()) span.textContent = `True ${row}`; else span.textContent = `${col} ${row}`;
    }
    function renderAllAlignmentLabels() { document.querySelectorAll('.cell').forEach(setAlignmentLabel); }
    function refreshAlignmentLabels() {
      renderAllAlignmentLabels();
      fitAllAlignmentLabels();
      fitHeadersResponsive();
    }

    function fitLabel(label, rect, base, padTopBottom = 10) {
      if (!label) return { height: 0 };
      if (!labelsVisible) {
        label.style.display = 'none';
        return { height: 0 };
      }

      const avail = rect.width * 0.9;
      const size = Math.min(ALIGN_FONT_MAX, Math.max(ALIGN_FONT_MIN, base * 0.11));

      // Start with single-line, consistent size
      label.style.whiteSpace = 'nowrap';
      label.style.display = 'block';
      label.style.webkitLineClamp = '';
      label.style.webkitBoxOrient = '';
      label.style.fontSize = `${size}px`;
      label.style.setProperty('--alignment-font-size', `${size}px`);

      // If the single line overflows, allow up to two lines
      if (label.scrollWidth > avail) {
        label.style.whiteSpace = 'normal';
        label.style.display = '-webkit-box';
        label.style.webkitBoxOrient = 'vertical';
        label.style.webkitLineClamp = '2';
      }

      return { height: label.offsetHeight + padTopBottom };
    }

    function measureAvatarSize(cell) {
      const content = cell.querySelector('.content');
      const avatar = content.querySelector('.avatar, .custom-image');
      const handle = cell.querySelector('.handle');
      const label = cell.querySelector('.alignment');
      if (!avatar) return null;

      const rect = cell.getBoundingClientRect();
      const base = Math.min(rect.width, rect.height);

      // Ensure handle size is measured based on cell size
      const handleSize = Math.max(10, base * 0.08);
      if (handle) handle.style.fontSize = `${handleSize}px`;

      const padTopBottom = 10;
      const { height: fittedLabelH } = fitLabel(label, rect, base, padTopBottom);

      const reservedLabelH = labelsVisible ? fittedLabelH : 4;
      const handleH = handle ? (handle.offsetHeight + padTopBottom) : padTopBottom;

      const availW = rect.width * 0.94;
      const availH = rect.height - reservedLabelH - handleH;

      return Math.max(32, Math.min(availW, availH));
    }

    function updateAvatarSizes() {
      const cells = Array.from(document.querySelectorAll('.cell'));
      if (!cells.length) return;
      const sizes = cells.map(measureAvatarSize).filter(s => typeof s === 'number');
      const minSize = sizes.length ? Math.min(...sizes) : null;
      cells.forEach(cell => adjustSizes(cell, minSize));
    }

    function initBoardResizer() {
      const board = document.getElementById('board');
      const handle = document.getElementById('boardResizer');
      if (!board || !handle) return;

      let dragging = false;
      let startSize = 0;
      let startX = 0;
      let startY = 0;

      const clampSize = s => Math.max(220, Math.min(1400, s));

      const onMove = e => {
        if (!dragging) return;
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const deltaX = clientX - startX;
        const deltaY = clientY - startY;
        const delta = Math.max(deltaX, deltaY);
        const newSize = clampSize(startSize + delta);
        userBoardSize = newSize;
        applyBoardSize(newSize);
        fitHeadersResponsive();
      };

      const onUp = () => {
        dragging = false;
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', onUp);
        window.removeEventListener('touchmove', onMove);
        window.removeEventListener('touchend', onUp);
      };

      const onDown = e => {
        e.preventDefault();
        const rect = board.getBoundingClientRect();
        startSize = rect.width;
        startX = e.touches ? e.touches[0].clientX : e.clientX;
        startY = e.touches ? e.touches[0].clientY : e.clientY;
        dragging = true;
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);
        window.addEventListener('touchmove', onMove, { passive: true });
        window.addEventListener('touchend', onUp);
      };

      handle.addEventListener('mousedown', onDown);
      handle.addEventListener('touchstart', onDown, { passive: true });
    }

    // ==== Rendering cells ====
    function adjustSizes(cell, uniformSize) {
      const content = cell.querySelector('.content');
      const avatar = content.querySelector('.avatar, .custom-image');
      const plain = content.querySelector('.plain-text');
      const placeholder = content.querySelector('.placeholder');
      const handle = cell.querySelector('.handle');
      const label = cell.querySelector('.alignment');
      const rect = cell.getBoundingClientRect();
      const base = Math.min(rect.width, rect.height);

      // Plain text or placeholder cells: size and center text relative to cell
      const textContent = plain || placeholder;
      if (textContent && !avatar) {
        const fontSize = Math.max(12, base * (plain ? 0.14 : 0.12));
        textContent.style.fontSize = `${fontSize}px`;
        const { height: fittedLabelH } = fitLabel(label, rect, base);
        // Center text within remaining space when labels show; otherwise center cell
        const shiftY = labelsVisible ? fittedLabelH / 2 : 0;
        textContent.style.transform = `translateY(${shiftY}px)`;

        // Apply matching font for plain text, reset for placeholders
        if (plain && textContent === plain) {
          const ff = fontFamilyFor(textContent.textContent);
          textContent.style.fontFamily = ff || '';
        } else {
          textContent.style.fontFamily = '';
        }
        return;
      }

      if (!avatar) return;

      // Handle font-size based on cell size
      const handleSize = Math.max(10, base * 0.08);
      if (handle) {
        handle.style.fontSize = `${handleSize}px`;
      }

      const padTopBottom = 10;
      const { height: fittedLabelH } = fitLabel(label, rect, base, padTopBottom);

      // Actual reserved height for label area depends on visibility
      const reservedLabelH = labelsVisible ? fittedLabelH : 4;
      const handleH = handle ? (handle.offsetHeight + padTopBottom) : padTopBottom;

      const availW = rect.width * 0.94;
      const availH = rect.height - reservedLabelH - handleH;

      const computedSize = Math.max(32, Math.min(availW, availH));
      const finalSize = uniformSize || computedSize;
      avatar.style.width = `${finalSize}px`;
      avatar.style.height = `${finalSize}px`;

      // When labels are hidden, lift avatar up by half the handle block
      const shiftY = labelsVisible ? 0 : handleH / 2;
      avatar.style.transform = `translateY(${-shiftY}px)`;
    }

    function positionWatermark() {
      const board = document.getElementById('board');
      const watermark = document.getElementById('boardWatermark');
      const midCell = document.getElementById('cell-nn'); // middle cell of middle row
      const rightCell = document.getElementById('cell-cn'); // right cell of middle row

      if (!board || !watermark || !midCell || !rightCell) return;

      const boardRect = board.getBoundingClientRect();
      const midRect = midCell.getBoundingClientRect();
      const rightRect = rightCell.getBoundingClientRect();

      // Horizontal gap between middle and right cells
      const gapLeft = midRect.right;
      const gapRight = rightRect.left;
      const gapWidth = Math.max(0, gapRight - gapLeft);

      // Vertical center of the middle row
      const centerY = (midRect.top + midRect.bottom) / 2;

      // Font size based on cell height so it roughly matches handle size
      const cellHeight = midRect.height;
      const fontSize = Math.max(10, cellHeight * 0.08); // similar to handle font sizing
      watermark.style.fontSize = `${fontSize}px`;

      // Reset position & transform to measure actual text width
      watermark.style.left = '0px';
      watermark.style.top = '0px';
      watermark.style.transform = 'none';

      const wmRect = watermark.getBoundingClientRect();
      const textWidth = wmRect.width;

      // If text is wider than gap, just center it on the gap center
      const gapCenterX = gapLeft + gapWidth / 2;
      let left;
      if (textWidth <= gapWidth) {
        // Perfectly center the text inside the gap
        left = gapLeft + (gapWidth - textWidth) / 2;
      } else {
        // Fallback: center on the gap center so it doesn't drift too far right
        left = gapCenterX - textWidth / 2;
      }

      // Position relative to board
      watermark.style.left = `${left - boardRect.left}px`;
      watermark.style.top = `${centerY - boardRect.top}px`;

      // Vertically center, no horizontal shift; rotate to match vertical style
      watermark.style.transform = 'translateY(-50%) rotate(180deg)';
    }



    function renderCell(cell) {
      setAlignmentLabel(cell);
      const content = cell.querySelector('.content');
      const raw = (cell.dataset.raw || '').trim();
      content.innerHTML = '';

      if (!raw) {
        const ph = document.createElement('div');
        ph.className = 'placeholder';
        ph.textContent = 'Click to add';
        content.appendChild(ph);
        updateHandlesText();
        return;
      }

      const handle = parseHandle(raw);
      const imageEntry = parseImageEntry(raw);
      const cellIndex = () => {
        const r = Number(cell.dataset.rowIndex);
        const c = Number(cell.dataset.colIndex);
        return r * 3 + c + 1; // 1..9 in row-major order
      };

      // If prefixed with @ and parsed, render as X handle with avatar/link
      if (raw.startsWith('@') && handle) {
        const img = document.createElement('img');
        img.className = 'avatar';
        img.alt = `@${handle}`;
        img.dataset.handle = handle;
        img.src = avatarURL(handle);

        const p = document.createElement('div');
        p.className = 'handle';
        p.innerHTML = `<a href="${profileURL(handle)}" target="_blank" rel="noopener noreferrer">@${handle}</a>`;
        p.querySelector('a').addEventListener('click', e => e.stopPropagation());
        content.append(img, p);
        updateAvatarSizes();
        updateHandlesText();
        return;
      }

      // Image URL (with optional label after '|')
      if (imageEntry) {
        const labelText = imageEntry.label || `Img${cellIndex()}`;
        const img = document.createElement('img');
        img.className = 'custom-image';
        img.src = imageEntry.url;
        img.alt = labelText;
        img.onerror = () => { img.src = PLACEHOLDER_IMG; };

        const label = document.createElement('div');
        label.className = 'handle image-label';
        label.textContent = labelText;
        const warn = document.createElement('div');
        warn.className = 'image-unavailable';
        warn.textContent = 'Image unavailable';

        label.addEventListener('click', e => {
          e.stopPropagation();
          editImageLabel(cell, imageEntry.url, imageEntry.label || '');
        });

        img.addEventListener('click', e => {
          e.stopPropagation();
          cell.dataset.raw = '';
          renderCell(cell);
          saveAll();
        });

        content.append(img, label, warn);
        updateAvatarSizes();
        updateHandlesText();
        return;
      }

      // Otherwise, treat as plain text
      const text = document.createElement('div');
      text.className = 'plain-text';
      text.textContent = raw;
      content.appendChild(text);
      updateAvatarSizes();
      updateHandlesText();
    }

    function editImageLabel(cell, dataUrl, existingLabel = '') {
      const content = cell.querySelector('.content');
      content.innerHTML = '';
      const wrap = document.createElement('div');
      wrap.className = 'inline-edit image-edit';

      const img = document.createElement('img');
      img.className = 'custom-image';
      img.src = dataUrl;
      img.alt = existingLabel || 'Image';
      img.onerror = () => { img.src = PLACEHOLDER_IMG; };

      const input = document.createElement('input');
      input.type = 'text';
      input.value = existingLabel;
      input.placeholder = 'Label for pasted image (optional)';

      wrap.append(img, input);
      content.append(wrap);
      input.focus();
      input.select();

      function commitImage() {
        const lbl = (input.value || '').trim();
        cell.dataset.raw = dataUrl + (lbl ? `|${lbl}` : '');
        renderCell(cell);
        saveAll();
      }
      input.addEventListener('blur', commitImage);
      input.addEventListener('keydown', e => { if (e.key === 'Enter') input.blur(); if (e.key === 'Escape') renderCell(cell); });
    }

    function editCell(cell) {
      const content = cell.querySelector('.content');
      const current = cell.dataset.raw || '';
      content.innerHTML = '';
      const wrap = document.createElement('div');
      wrap.className = 'inline-edit';
      const currentImage = parseImageEntry(current);

      if (currentImage) {
        editImageLabel(cell, currentImage.url, currentImage.label || '');
        return;
      }

      const input = document.createElement('input');
      input.type = 'text';
      input.value = current;
      input.placeholder = 'Start with @ for X handle, or paste image data|label';
      wrap.append(input);
      content.append(wrap);
      input.focus();
      input.select();
      input.addEventListener('paste', e => {
        const items = e.clipboardData && e.clipboardData.items;
        if (!items) return;
        for (const item of items) {
          if (item.type && item.type.startsWith('image/')) {
            e.preventDefault();
            const file = item.getAsFile();
            if (!file) return;
            const reader = new FileReader();
            reader.onload = () => {
              const dataUrl = reader.result;
              cell.dataset.raw = dataUrl;
              renderCell(cell);
              // Immediately prompt for label on pasted image
              editImageLabel(cell, dataUrl, '');
              saveAll();
            };
            reader.readAsDataURL(file);
            break;
          }
        }
      });
      function commit() {
        const raw = (input.value || '').trim();
        if (raw.startsWith('@')) {
          const h = parseHandle(raw);
          cell.dataset.raw = h ? `@${h}` : '';
        } else if (parseImageEntry(raw)) {
          // Normalize: data URL|label (label optional)
          const entry = parseImageEntry(raw);
          const rebuilt = entry.url + (entry.label ? `|${entry.label}` : '');
          cell.dataset.raw = rebuilt;
        } else {
          cell.dataset.raw = raw;
        }
        renderCell(cell);
        saveAll();
      }
      input.addEventListener('blur', commit);
      input.addEventListener('keydown', e => { if (e.key === 'Enter') input.blur(); if (e.key === 'Escape') renderCell(cell); });
    }

    // Wire cell interactions
    document.querySelectorAll('.cell').forEach(cell => {
      setAlignmentLabel(cell);
      renderCell(cell);
      cell.addEventListener('click', e => { if (e.target.classList.contains('alignment')) return; editCell(cell); });
    });

    // ==== Editable headers ====
    function editHeader(kind, index) {
      const id = `${kind}-${index}`;
      const el = document.getElementById(id);
      if (!el) return;
      const current = (kind === 'col' ? colTitles[index] : rowTitles[index]);
      const wrap = document.createElement('div');
      wrap.className = 'hdr hdr-edit' + (kind === 'row' ? ' row' : '');
      const input = document.createElement('input');
      input.type = 'text'; input.value = current; input.size = Math.max(4, Math.min(14, current.length));
      el.replaceWith(wrap); wrap.appendChild(input); input.focus(); input.select();
      function commit() { const val = (input.value || '').trim() || current; if (kind === 'col') { colTitles[index] = val; } else { rowTitles[index] = val; } saveTitles(); const display = document.createElement('div'); display.id = id; display.className = 'hdr ' + (kind === 'row' ? 'row' : 'col'); display.setAttribute('role', 'button'); display.textContent = val; wrap.replaceWith(display); display.style.cssText = (kind === 'row') ? 'grid-column: 1; grid-row: ' + (index + 2) + '; margin-right: -10px;' : 'grid-column: ' + (index + 2) + '; grid-row: 1; margin-bottom: -10px;'; hookHeader(display); refreshAlignmentLabels(); updateHandlesText(); sizeBoard(); fitHeadersResponsive(); }
      function cancel() { const display = document.createElement('div'); display.id = id; display.className = 'hdr ' + (kind === 'row' ? 'row' : 'col'); display.setAttribute('role', 'button'); display.textContent = current; wrap.replaceWith(display); hookHeader(display); }
      input.addEventListener('blur', commit);
      input.addEventListener('keydown', e => { if (e.key === 'Enter') input.blur(); if (e.key === 'Escape') cancel(); });
    }

    function hookHeader(el) {
      if (el.id.startsWith('col-')) { const i = Number(el.id.split('-')[1]); el.addEventListener('click', () => editHeader('col', i)); }
      if (el.id.startsWith('row-')) { const i = Number(el.id.split('-')[1]); el.addEventListener('click', () => editHeader('row', i)); }
    }
    document.querySelectorAll('.hdr.col, .hdr.row').forEach(hookHeader);

    // ==== Persistence of handles ====
    function saveAll() {
      const data = { __v: 2 };
      document.querySelectorAll('.cell').forEach(c => {
        data[c.id] = { raw: c.dataset.raw || '' };
      });
      localStorage.setItem('alignment_handles', JSON.stringify(data));
    }
    function loadAll() {
      const r = localStorage.getItem('alignment_handles');

      // No key at all ‚Üí first visit
      if (!r) {
        return { hasKey: false, hasAny: false };
      }

      try {
        const d = JSON.parse(r);
        const isV2 = d && d.__v === 2;
        let hasAny = false;

        Object.entries(d).forEach(([id, h]) => {
          if (id === '__v') return;
          const c = document.getElementById(id);
          if (c) {
            let raw = '';
            if (isV2 && h && typeof h.raw === 'string') {
              raw = h.raw;
            } else if (!isV2 && typeof h === 'string') {
              // Legacy data: stored bare handle; prefix @
              raw = h ? `@${h}` : '';
            }
            c.dataset.raw = raw;
            if (raw) hasAny = true;
            renderCell(c);
          }
        });

        return { hasKey: true, hasAny };
      } catch {
        // If parsing fails, treat as no usable data
        return { hasKey: false, hasAny: false };
      }
    }


    // ==== Header buttons ====

    const labelsBtn = document.getElementById('labelsBtn');

    // global flag for visibility of alignment labels
    let labelsVisible = (localStorage.getItem('alignment_labels') || 'on') === 'on';

    function setLabels(on) {
      labelsVisible = on;

      document.querySelectorAll('.alignment').forEach(a => {
        a.style.display = on ? '' : 'none';
      });

      labelsBtn.setAttribute('aria-pressed', on);
      labelsBtn.textContent = `Labels: ${on ? 'On' : 'Off'}`;
      localStorage.setItem('alignment_labels', on ? 'on' : 'off');

      // recalculate board & avatar sizes whenever labels are shown/hidden
      sizeBoard();
    }

    labelsBtn.addEventListener('click', () => setLabels(!labelsVisible));

    // apply initial state from localStorage
    setLabels(labelsVisible);


    const refreshBtn = document.getElementById('refreshBtn');

    function refreshAvatars() {
      document.querySelectorAll('.cell').forEach(cell => {
        const raw = (cell.dataset.raw || '').trim();
        const handle = raw.startsWith('@') ? parseHandle(raw) : '';
        if (!handle) return;

        const img = cell.querySelector('.avatar');
        if (img) {
          // Force a fresh fetch (bust unavatar cache by adding a timestamp)
          const base = avatarURL(handle);
          const sep = base.includes('?') ? '&' : '?';
          img.src = `${base}${sep}t=${Date.now()}`;
        } else {
          renderCell(cell);
        }
      });
    }

    const COOLDOWN_MS = 60000;
    let refreshCooldownTimeout = null;

    function startRefreshCooldown() {
      // Disable button and add class for visual state
      refreshBtn.disabled = true;
      refreshBtn.classList.add('refresh-cooling');

      const bar = refreshBtn.querySelector('.cooldown-bar');
      if (bar) {
        bar.style.animation = 'none';
        void bar.offsetWidth;          // reset animation
        bar.style.opacity = '1';       // NEW: ensure visible during cooldown
        bar.style.animation = `cooldownFill ${COOLDOWN_MS}ms linear forwards`;
      }


      // Re-enable after cooldown
      if (refreshCooldownTimeout) {
        clearTimeout(refreshCooldownTimeout);
      }
      refreshCooldownTimeout = setTimeout(() => {
        refreshBtn.disabled = false;
        refreshBtn.classList.remove('refresh-cooling');

        if (bar) {
          // Stop animation and hide the bar completely
          bar.style.animation = 'none';
          bar.style.width = '0';
          bar.style.opacity = '0';
        }

      }, COOLDOWN_MS);

    }

    // Replace the old listener with this:
    refreshBtn.addEventListener('click', () => {
      if (refreshBtn.disabled) return;  // ignore spam clicks during cooldown
      refreshAvatars();
      startRefreshCooldown();
    });




    const clearBtn = document.getElementById('clearBtn');
    clearBtn.addEventListener('click', () => {
      document.querySelectorAll('.cell').forEach(cell => { cell.dataset.raw = ''; renderCell(cell); });
      saveAll();
      updateHandlesText();
    });

    const resetLabelsBtn = document.getElementById('resetLabelsBtn');
    resetLabelsBtn.addEventListener('click', () => { colTitles = [...DEFAULT_COLS]; rowTitles = [...DEFAULT_ROWS]; saveTitles(); document.getElementById('col-0').textContent = colTitles[0]; document.getElementById('col-1').textContent = colTitles[1]; document.getElementById('col-2').textContent = colTitles[2]; document.getElementById('row-0').textContent = rowTitles[0]; document.getElementById('row-1').textContent = rowTitles[1]; document.getElementById('row-2').textContent = rowTitles[2]; refreshAlignmentLabels(); updateHandlesText(); sizeBoard(); fitHeadersResponsive(); });

    const fmkLabelsBtn = document.getElementById('fmkLabelsBtn');

    fmkLabelsBtn.addEventListener('click', () => {
      // Set new FMK titles
      colTitles = ['Trust', 'Doubt', 'Fear'];
      rowTitles = ['Fuck', 'Marry', 'Kill'];

      // Persist them
      saveTitles();

      // Update header elements in the DOM
      document.getElementById('col-0').textContent = colTitles[0];
      document.getElementById('col-1').textContent = colTitles[1];
      document.getElementById('col-2').textContent = colTitles[2];

      document.getElementById('row-0').textContent = rowTitles[0];
      document.getElementById('row-1').textContent = rowTitles[1];
      document.getElementById('row-2').textContent = rowTitles[2];

      // Rebuild cell alignment labels (including True X logic)
      renderAllAlignmentLabels();
      updateHandlesText();
    });


    // ==== Initial paint ====
    refreshAlignmentLabels();

      const handleState = loadAll();

      // Default middle handle appears if:
      // 1) user has never saved handles before (first visit), OR
      // 2) user has saved before but currently all handles are empty (after clearing)
      if (!handleState.hasKey || !handleState.hasAny) {
        const midCell = document.getElementById('cell-nn'); // center cell
        if (midCell) {
          midCell.dataset.raw = `@${DEFAULT_MID_HANDLE}`;
          renderCell(midCell);
          saveAll();
          updateHandlesText();
        }
      }

      applyXSymbolFallback();
      initBoardResizer();

      function kick() {
        sizeBoard();
        requestAnimationFrame(sizeBoard);
      }
    kick();


  </script>
</body>
